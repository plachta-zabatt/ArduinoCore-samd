/* 
  OneLink.h - Library for running a OneLink node

  TODO://
	--(GENERAL) Use byte instead of bools?
	--(GENERAL) How the crap are we going to keep all these libraries updated-- do we want to ? How is this all going to be organized
		code hierarchy wise?

	--(OL_CYCLE)Pull out send msg into its own function
	--(OL_CYCLE)Stop using external declared lora class, remove that and declare our own that belongs as a member of OneLinkNodeClass
	--(OL_CYCLE)How exactly are we sending commands or data to this unit? 
		---1: CommandID, 2: Extar 
	--(OL_CYCLE) Store 'last joined' millis so we can more intelligently join and rejoin
	--(LOW POWER) Stop using externally declared lowpower class same as the lora class thing.. Bring it in here because .. why not. 
		This is our thing sitting on top of everything else.

*/

#include "OneLink.h"

OneLinkNodeClass::OneLinkNodeClass()
{

	int x{ 5 };
}
OneLinkNodeClass::~OneLinkNodeClass()
{
}


/*
**************************************************************************************************
*
*	TODO://
*		-Add other pieces like initing sleep, initing DEEP sleep, any lights or I/O
*
* Description : Initialize the differnet libraries we are using, apply settings, 
*					and do any setup we need for our node. This will run for the first time before 
*					being sent out to the customer.
*
* Arguments   : 
* Returns	  :
**************************************************************************************************
*/
bool OneLinkNodeClass::init()
{
	
	Serial.begin(115200);
	delay(3000);

	Serial.println("-------- 1 ----------");

	////////////TESTING ONLY
	// set up pins for testing only
	pinMode(pinWakeup, INPUT_PULLUP);
  	pinMode(pinLED_red, OUTPUT);
  	pinMode(pinLED_green, OUTPUT);
  	pinMode(pinLED_blue, OUTPUT);

    digitalWrite(pinLED_red, LOW);
    digitalWrite(pinLED_green, HIGH);
	delay(100);



	//initLorawan();
	//initSleep();

	return 1;
}


/*
**************************************************************************************************
*
*	TODO://
*		-Pull all of these settings, especially devEUI and appKey, from different files. At some point it
*			is going to be necessary to be able to change these things easily (especially dev and app keys)
*
* Description :	Do the loraWAN initilization (generic settings)
* 
* Arguments   : 
* Returns	  :
**************************************************************************************************
*/
bool OneLinkNodeClass::initLorawan()
{
	// OTAA credentials
	const char *devEui = "93311b1e9d70fec6";
	const char *appEui = "0000000000000000";
	const char *appKey = "d9988a5f02d80fab8ba5f453c4a2cd2b";


	if (!lora.init()) {
		Serial.println("RFM95 not detected");
		delay(10000);
		return 0;
	}

	//All settings, including different EUI's. This is super poorly done and will have to be re-done later...
  	lora.setDeviceClass(CLASS_A);
	lora.setDataRate(SF7BW125);
  	lora.setChannel(MULTI);
	lora.setDevEUI(devEui);
	lora.setAppEUI(appEui);
	lora.setAppKey(appKey);

	join();
	return 1;
}


bool OneLinkNodeClass::initSleep()
{
	LowPower.attachInterruptWakeup(pinWakeup, NULL, CHANGE);

	// for(int x=0;x<4;x++)
	// {
	// 	digitalWrite(pinLED_green, LOW);
	// 	delay(100);
	// 	digitalWrite(pinLED_green, HIGH);
	// 	delay(100);
	// }

	return 1;
}
/*
**************************************************************************************************
*
*	TODO://
*		-
*
* Description :	General holder of the per-loop cycle. Join, read commands, TX, decode and execute RX
*
* Arguments   : 
* Returns	  :
**************************************************************************************************
*/
bool OneLinkNodeClass::onelinkCycle()
{
	for(int x=0;x<4;x++)
	{
		digitalWrite(pinLED_green, LOW);
		delay(100); 
		digitalWrite(pinLED_green, HIGH);
		delay(100);
	}


	// for(int x=0;x<4;x++)
	// {
	// 	digitalWrite(pinLED_green, LOW);
	// 	delay(100); 
	// 	digitalWrite(pinLED_green, HIGH);
	// 	delay(100);
	// }

	/*
	readSensors();
	writeMessage();
	lora.update();
	readCommnds();
	  */
	return 1;
}


/*
**************************************************************************************************
*
*	TODO://
*
* Description :	
*
* Arguments   : 
* Returns	  :
**************************************************************************************************
*/
bool OneLinkNodeClass::join()
{
	Serial.println("-------- 2 ----------");
	bool isJoined;
	do {
		Serial.println("Joining...");
		isJoined = lora.join(); 

		//wait for 10s to try again
		delay(5000);
	} while (!isJoined);
	Serial.println("Joined to network");
	Serial.println("---------------------------------------");
	Serial.println("---------------------------------------");
	Serial.println();
	Serial.println();
	Serial.println();
	Serial.println();
	Serial.println();


	return 1;
}


/*
**************************************************************************************************
*
*	TODO://
*
* Description :	
*
* Arguments   : 
* Returns	  :
**************************************************************************************************
*/
bool OneLinkNodeClass::readSensors()
{
	// Wipe? ... This seems like the correct way to do it, though.... need to verify I'm not creating a memory leak
	readings = SensorReadings();
	
	readings.loadAC = 12333;
	readings.loadGen = 0;
	readings.emergencyPower = 1;
	readings.CT1 = 12345678;
	readings.CT2 = 0;
	
	return 1;
}


/*
**************************************************************************************************
*
*	TODO://
*
* Description :	construct message and put it in the correct reg's using the beelan library
*
* Arguments   : 
* Returns	  :
**************************************************************************************************
*/
bool OneLinkNodeClass::writeMessage()
{
	const unsigned short int bufferCount = 230; //size of json struct, size of output buff...
	bool confirmed = false;
	unsigned short int mport = 1;
	StaticJsonDocument<bufferCount> jsonBuffer;
	unsigned short int outputBufferLen;
	char outputBuffer[bufferCount];
	
	//convert struct we read in to json
	jsonBuffer[(String)Sensor_loadAC] = readings.loadAC;
	jsonBuffer[(String)Sensor_loadGen] = readings.loadGen;
	jsonBuffer[(String)Sensor_emergencyPower] = (int)readings.emergencyPower;
	jsonBuffer[(String)Sensor_CT1] = readings.CT1;
	jsonBuffer[(String)Sensor_CT2] = readings.CT2;

    outputBufferLen = serializeJson(jsonBuffer, outputBuffer, bufferCount);

	Serial.println("-------- 3 ----------");
	Serial.println(outputBuffer);

	///Pull out to own method
	lora.sendUplink(outputBuffer, outputBufferLen, confirmed, mport);

	return 1;
}


/*
**************************************************************************************************
*
*	TODO://
*
* Description :	
*
* Arguments   : 
* Returns	  :
**************************************************************************************************
*/
bool OneLinkNodeClass::readCommnds()
{
	const unsigned short int bufferCount = 255; //size of json struct, size of in buff...
	StaticJsonDocument<bufferCount> inputBuffer;
	char outStr[bufferCount];
	byte recvStatus = 0;

  	recvStatus = lora.readData(outStr);
	  
	if (recvStatus) {

		Serial.println("\n----");
		// DeserializationError err = deserializeJson(inputBuffer, outStr);
		// if(err){
		// 	Serial.print("*********err : ");
		// 	Serial.print(err.c_str()); 
		// 	Serial.println();
		// }

		Serial.println("\n----");
		Serial.println("---- RECEIVED -------------------");
		Serial.println((String)"OutStr: " + outStr);
		Serial.println("---- RECEIVED -------------------");
		Serial.println("----");
	}

	return 1;
}



/*
**************************************************************************************************
*
*	TODO://
*
* Description :	
*
* Arguments   : 
* Returns	  :
**************************************************************************************************
*/
bool OneLinkNodeClass::update()
{
	return 0;
}
